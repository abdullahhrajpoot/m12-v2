{
  "name": "Bippity - Gmail Command Poller MultiTenant",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "minutes",
              "minutesInterval": 10
            }
          ]
        }
      },
      "id": "schedule-trigger",
      "name": "Schedule Trigger",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.3,
      "position": [-600, 0]
    },
    {
      "parameters": {
        "resource": "message",
        "operation": "getAll",
        "returnAll": false,
        "filters": {
          "search": "to:fgm@gmail.com -label:bippity-processed is:unread"
        },
        "limit": 50,
        "options": {
          "simplify": false,
          "format": "full"
        }
      },
      "id": "search-gmail",
      "name": "Search Gmail for Commands",
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2.2,
      "position": [-200, 0],
      "alwaysOutputData": true,
      "credentials": {
        "gmailOAuth2": {
          "id": "",
          "name": "FGM Gmail OAuth2"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Extract email content and headers\nfunction decodeBase64Url(data) {\n  if (!data) return '';\n  try {\n    return Buffer.from(data, 'base64url').toString('utf-8');\n  } catch (e) {\n    return '';\n  }\n}\n\nconst items = $input.all();\nconst results = [];\n\nfor (const item of items) {\n  const message = item.json;\n  \n  // Gmail node might return different structures - handle both\n  // Check if it's already simplified (has from, subject, etc. directly)\n  let fromEmail = message.from || message.fromEmail || '';\n  let subject = message.subject || '';\n  let toEmail = message.to || message.toEmail || '';\n  let messageId = message['message-id'] || message.messageId || '';\n  \n  // If not simplified, extract from payload\n  const payload = message.payload || {};\n  const headers = payload.headers || [];\n  \n  // Extract from headers if not already found\n  if (!fromEmail || !subject) {\n    for (const h of headers) {\n      if (!h || !h.name || !h.value) continue;\n      const name = String(h.name).toLowerCase();\n      const value = String(h.value).trim();\n      \n      if (name === 'from' && !fromEmail) {\n        // Extract email from \"Name <email@domain.com>\" or just \"email@domain.com\"\n        const emailMatch = value.match(/<([^>]+)>/) || value.match(/([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,})/);\n        if (emailMatch) fromEmail = emailMatch[1] || emailMatch[0];\n      } else if (name === 'to' && !toEmail) {\n        toEmail = value;\n      } else if (name === 'subject' && !subject) {\n        subject = value;\n      } else if (name === 'message-id' && !messageId) {\n        messageId = value;\n      }\n    }\n  }\n  \n  // Extract body text\n  let bodyText = message.textBody || message.body || '';\n  \n  if (!bodyText && payload.parts && Array.isArray(payload.parts)) {\n    for (const part of payload.parts) {\n      if (part.mimeType === 'text/plain' && part.body && part.body.data) {\n        bodyText += decodeBase64Url(part.body.data);\n      } else if (part.mimeType === 'text/html' && part.body && part.body.data && !bodyText) {\n        // Fallback to HTML if no plain text\n        bodyText += decodeBase64Url(part.body.data);\n      }\n    }\n  } else if (!bodyText && payload.body && payload.body.data) {\n    bodyText = decodeBase64Url(payload.body.data);\n  }\n  \n  // Debug: log if from_email is still empty\n  if (!fromEmail) {\n    console.error('No from_email found in message:', JSON.stringify(message, null, 2).substring(0, 500));\n  }\n  \n  results.push({\n    json: {\n      gmail_message_id: message.id || message.messageId || '',\n      thread_id: message.threadId || message.thread_id || '',\n      from_email: fromEmail,\n      to_email: toEmail,\n      subject: subject || '',\n      content: bodyText.trim(),\n      raw_message: message\n    }\n  });\n}\n\nreturn results.length > 0 ? results : [{ json: { error: 'No email data extracted' } }];"
      },
      "id": "extract-email-content",
      "name": "Extract Email Content",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [400, 0],
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "users",
        "matchType": "allFilters",
        "filters": {
          "conditions": [
            {
              "keyName": "email",
              "condition": "ilike",
              "keyValue": "={{ $json.from_email }}"
            }
          ]
        }
      },
      "id": "match-user",
      "name": "Match User by Email",
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [600, 0],
      "alwaysOutputData": true,
      "credentials": {
        "supabaseApi": {
          "id": "LiyXJ3va3HnvvAkS",
          "name": "Supabase account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "version": 3,
            "leftValue": "",
            "caseSensitive": true,
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "check-user-found",
              "leftValue": "={{ $json.id }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEmpty"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-user-found",
      "name": "User Found?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [800, 0],
      "alwaysOutputData": false
    },
    {
      "parameters": {
        "jsCode": "// Get user_id from matched user (this node only runs if user was found)\n// Get current item from input (user data from Match User by Email)\nconst items = $input.all();\nconst userData = items[0]?.json || {};\n\n// Get email data from Extract Email Content node\n// Since items are processed sequentially, we need to find the matching email\n// We'll match by from_email since that's what we used to query\nlet emailData = {};\nconst userEmail = userData.email || '';\n\ntry {\n  // Get all emails from Extract Email Content node\n  const allEmailData = $('Extract Email Content').all();\n  \n  // Find the email that matches this user's email (from_email)\n  if (allEmailData && allEmailData.length > 0) {\n    // Since items are processed sequentially, the current item index should match\n    // But to be safe, we'll search by email address\n    const matchingEmail = allEmailData.find(item => {\n      const email = item.json?.from_email || '';\n      return email.toLowerCase() === userEmail.toLowerCase();\n    });\n    \n    if (matchingEmail) {\n      emailData = matchingEmail.json || {};\n    } else if (allEmailData.length > 0) {\n      // Fallback: if we can't find by email, use the first available\n      // This shouldn't happen in normal flow, but handles edge cases\n      emailData = allEmailData[0].json || {};\n    }\n  }\n} catch (e) {\n  // Fallback: if we can't get email data, continue with user data only\n  console.error('Error getting email data:', e);\n}\n\n// Get user ID from current item (user data from Match User by Email)\nconst userId = userData?.id;\n\nif (!userId) {\n  return [{ json: { error: 'User data not found', from_email: emailData?.from_email || userEmail, ...emailData } }];\n}\n\n// Merge email data with user data\nreturn [{\n  json: {\n    ...emailData,\n    user_id: userId,\n    user_email: userData.email || emailData?.from_email || ''\n  }\n}];"
      },
      "id": "prepare-unified-event",
      "name": "Prepare Unified Event",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1000, 0],
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "operation": "create",
        "tableId": "unified_events",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $json.user_id }}"
            },
            {
              "fieldId": "source_type",
              "fieldValue": "email_command"
            },
            {
              "fieldId": "source_item_id",
              "fieldValue": "={{ $json.gmail_message_id }}"
            },
            {
              "fieldId": "content",
              "fieldValue": "={{ $json.content }}"
            },
            {
              "fieldId": "subject",
              "fieldValue": "={{ $json.subject }}"
            },
            {
              "fieldId": "sender_email",
              "fieldValue": "={{ $json.from_email }}"
            },
            {
              "fieldId": "processing_status",
              "fieldValue": "pending"
            },
            {
              "fieldId": "raw_data",
              "fieldValue": "={{ JSON.stringify($json.raw_message) }}"
            }
          ]
        }
      },
      "id": "create-unified-event",
      "name": "Create Unified Event",
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [1200, 0],
      "alwaysOutputData": true,
      "credentials": {
        "supabaseApi": {
          "id": "LiyXJ3va3HnvvAkS",
          "name": "Supabase account"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "workflowId": "4rleLK1hglMsB9GT",
        "source": "database",
        "mode": "once",
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "unified_event_id": "={{ $json.id }}",
            "user_id": "={{ $json.user_id }}",
            "email_content": "={{ $json.content }}",
            "subject": "={{ $json.subject }}",
            "sender_email": "={{ $json.sender_email }}"
          },
          "matchingColumns": {},
          "schema": []
        },
        "options": {
          "waitForSubWorkflow": true
        }
      },
      "id": "execute-command-processor",
      "name": "Execute Command Processor",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.3,
      "position": [1400, 0],
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "jsCode": "// Check if processing was successful and determine email handling\n// Get current item from command processor output\nconst items = $input.all();\nconst processorResult = items[0]?.json || {};\n\n// Get unified event data from Create Unified Event node\nlet unifiedEventData = {};\ntry {\n  const allUnifiedEvents = $('Create Unified Event').all();\n  // Find the most recent unified event (last in array since items are processed sequentially)\n  if (allUnifiedEvents && allUnifiedEvents.length > 0) {\n    unifiedEventData = allUnifiedEvents[allUnifiedEvents.length - 1].json || {};\n  }\n} catch (e) {\n  // Fallback - unified event might not exist if creation failed\n}\n\n// Get email data from Extract Email Content node\nlet emailData = {};\ntry {\n  const allEmailData = $('Extract Email Content').all();\n  // Match by gmail_message_id if available, otherwise use last item\n  const gmailId = processorResult.gmail_message_id || unifiedEventData.source_item_id || '';\n  \n  if (gmailId && allEmailData) {\n    const matchingEmail = allEmailData.find(item => item.json?.gmail_message_id === gmailId);\n    if (matchingEmail) {\n      emailData = matchingEmail.json || {};\n    }\n  }\n  \n  // Fallback: use last email if we can't find by ID\n  if (!emailData.gmail_message_id && allEmailData && allEmailData.length > 0) {\n    emailData = allEmailData[allEmailData.length - 1].json || {};\n  }\n} catch (e) {\n  // Fallback\n}\n\nconst processingStatus = processorResult.processing_status || unifiedEventData.processing_status || 'error';\nconst gmailMessageId = emailData?.gmail_message_id || processorResult.gmail_message_id || unifiedEventData.source_item_id || '';\nconst threadId = emailData?.thread_id || processorResult.thread_id || '';\nconst unifiedEventId = unifiedEventData?.id || processorResult.unified_event_id || null;\n\n// Determine actions based on status\nconst shouldArchive = processingStatus === 'completed';\nconst shouldLabelError = processingStatus === 'error';\n\nreturn [{\n  json: {\n    gmail_message_id: gmailMessageId,\n    thread_id: threadId,\n    processing_status: processingStatus,\n    unified_event_id: unifiedEventId,\n    should_archive: shouldArchive,\n    should_label_error: shouldLabelError\n  }\n}];"
      },
      "id": "check-processing-result",
      "name": "Check Processing Result",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1600, 0],
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "version": 3,
            "leftValue": "",
            "caseSensitive": true,
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "check-should-archive",
              "leftValue": "={{ $json.should_archive }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "true"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "should-archive-email",
      "name": "Should Archive Email?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [1800, 0],
      "alwaysOutputData": false
    },
    {
      "parameters": {
        "url": "={{ 'https://gmail.googleapis.com/gmail/v1/users/me/messages/' + $json.gmail_message_id + '/modify' }}",
        "method": "POST",
        "sendBody": true,
        "contentType": "json",
        "specifyBody": "json",
        "jsonBody": "={\n  \"addLabelIds\": [\"bippity-processed\"],\n  \"removeLabelIds\": [\"UNREAD\", \"INBOX\"]\n}",
        "authentication": "predefinedCredentialType",
        "credentialType": "gmailOAuth2Api",
        "options": {}
      },
      "id": "archive-email",
      "name": "Archive and Label Email",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [2000, 0],
      "alwaysOutputData": true,
      "credentials": {
        "gmailOAuth2Api": {
          "id": "",
          "name": "FGM Gmail OAuth2"
        }
      }
    },
    {
      "parameters": {
        "url": "={{ 'https://gmail.googleapis.com/gmail/v1/users/me/messages/' + $json.gmail_message_id + '/modify' }}",
        "method": "POST",
        "sendBody": true,
        "contentType": "json",
        "specifyBody": "json",
        "jsonBody": "={\n  \"addLabelIds\": [\"bippity-error\"]\n}",
        "authentication": "predefinedCredentialType",
        "credentialType": "gmailOAuth2Api",
        "options": {}
      },
      "id": "label-error-email",
      "name": "Label Error Email",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [2000, 200],
      "alwaysOutputData": true,
      "credentials": {
        "gmailOAuth2Api": {
          "id": "",
          "name": "FGM Gmail OAuth2"
        }
      }
    },
    {
      "parameters": {
        "operation": "send",
        "sendTo": "={{ $json.to_email }}",
        "subject": "={{ $json.subject }}",
        "emailType": "html",
        "message": "={{ $json.email_body }}",
        "options": {}
      },
      "id": "send-error-email",
      "name": "Send Error Email to Unmatched User",
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2.2,
      "position": [1000, 400],
      "alwaysOutputData": true,
      "continueOnFail": true,
      "credentials": {
        "gmailOAuth2": {
          "id": "",
          "name": "FGM Gmail OAuth2"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Prepare error email for Gmail send node\n// Get current item (this is from Match User by Email, which will be empty if no user found)\nconst items = $input.all();\nconst currentItem = items[0]?.json || {};\n\n// Get the corresponding email data from Extract Email Content node\nlet emailData = {};\ntry {\n  const allEmailData = $('Extract Email Content').all();\n  \n  // Try to match by from_email if available in current item\n  if (currentItem.from_email && allEmailData) {\n    const matchingEmail = allEmailData.find(item => {\n      const email = item.json?.from_email || '';\n      return email.toLowerCase() === currentItem.from_email.toLowerCase();\n    });\n    if (matchingEmail) {\n      emailData = matchingEmail.json || {};\n    }\n  }\n  \n  // Fallback: use the most recent email (last in array)\n  if (!emailData.from_email && allEmailData && allEmailData.length > 0) {\n    emailData = allEmailData[allEmailData.length - 1].json || {};\n  }\n} catch (e) {\n  // Fallback - use current item if it has email data\n  emailData = currentItem;\n}\n\nconst toEmail = emailData.from_email || emailData.email || currentItem.from_email || '';\nconst subject = 'Re: ' + (emailData.subject || 'Your email to Bippity.boo');\nconst contentPreview = (emailData.content || '').substring(0, 500).replace(/\\n/g, '<br>');\nconst body = `Hi,<br><br>I received your email but couldn't find an account associated with <strong>${toEmail}</strong>.<br><br>To use Bippity.boo, please:<br>1. Visit <a href=\"https://bippity.boo\">https://bippity.boo</a><br>2. Sign up with Google using your email: ${toEmail}<br>3. Complete the onboarding process<br><br>Once you're set up, you can email me at fgm@gmail.com with commands like:<br>- \"Add fact: [your fact text]\"<br>- \"Show my calendar for [date]\"<br>- \"Create task: [task title] due [date]\"<br><br>- Your Fairy God Mother ðŸ¤–<br><br><hr><br><strong>Original message:</strong><br>Subject: ${emailData.subject || '(no subject)'}<br>${contentPreview}`;\n\nreturn [{\n  json: {\n    to_email: toEmail,\n    subject: subject,\n    email_body: body\n  }\n}];"
      },
      "id": "prepare-error-email",
      "name": "Prepare Error Email",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [800, 400],
      "alwaysOutputData": true
    }
  ],
  "connections": {
    "Schedule Trigger": {
      "main": [[{ "node": "Search Gmail for Commands", "type": "main", "index": 0 }]]
    },
    "Search Gmail for Commands": {
      "main": [[{ "node": "Extract Email Content", "type": "main", "index": 0 }]]
    },
    "Extract Email Content": {
      "main": [[{ "node": "Match User by Email", "type": "main", "index": 0 }]]
    },
    "Match User by Email": {
      "main": [[{ "node": "User Found?", "type": "main", "index": 0 }]]
    },
    "User Found?": {
      "main": [
        [{ "node": "Prepare Unified Event", "type": "main", "index": 0 }],
        [{ "node": "Prepare Error Email", "type": "main", "index": 0 }]
      ]
    },
    "Prepare Unified Event": {
      "main": [[{ "node": "Create Unified Event", "type": "main", "index": 0 }]]
    },
    "Create Unified Event": {
      "main": [[{ "node": "Execute Command Processor", "type": "main", "index": 0 }]]
    },
    "Execute Command Processor": {
      "main": [[{ "node": "Check Processing Result", "type": "main", "index": 0 }]]
    },
    "Check Processing Result": {
      "main": [[{ "node": "Should Archive Email?", "type": "main", "index": 0 }]]
    },
    "Should Archive Email?": {
      "main": [
        [{ "node": "Archive and Label Email", "type": "main", "index": 0 }],
        [{ "node": "Label Error Email", "type": "main", "index": 0 }]
      ]
    },
    "Prepare Error Email": {
      "main": [[{ "node": "Send Error Email to Unmatched User", "type": "main", "index": 0 }]]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "saveDataErrorExecution": "all",
    "saveDataSuccessExecution": "all",
    "saveManualExecutions": true,
    "saveExecutionProgress": true
  }
}
